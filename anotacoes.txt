COMO FAZER TS RODAR NO SEU VSCODE

* Instalando TS: npm i -D typescript
* Criar arquivo de config: npx tsc --init 
    * npx é feature do nodejs para executar binários executáveis
      de bibliotecas que baixamos (no caso, da biblioteca TS, a tsc)
* Agora você troca o ecmascript para versão mais recente (a fim de FAZER
  o TS compilar para versões mais recentes de JS): { "target": "es2020" }
* Para fazer node entender TS: npm install -D @types/node
* Para compilar um arquivo .ts para .js: npx tsc src/index.ts
* Depois só pega o arquivo .js gerado e: node src/index.js
* Para facilitar a vida:
  * npm install tsx -D => automatiza conversao para js e já executa
  * ex de uso: npx tsx /src/server.js
  * para agilizar mais, vai no packtage.json e adicione { "dev":"tsx watch src/server.ts" }
  * com isso, só executar npm run dev que pah, você converte tudo para js e compila 
    * além de que o WATCH faz o server ficar moniotrando alterações e atualizando a cada alteração
  * usamos só em ambiente desenvolvimento para facilitar testes
  * agora na produção o ideal é converter tudo para JS e compilar o JS 
    * facilita achar erros
    * é + rápido executar JS

INSTALANDO O FASTIFY

* npm i fastify 
* microframework para desenvolvimento de backend
* ele é microframework porque não determina/opina sobre estruturas de pastas
  ou padrões mais rígidos para seguir. Ele se concentra em funcionalidades;
* suporte nativo para TS sem precisar instalar novas bibliotecas

ESLINT

* Extensão
* npm install -D eslint
* tem comando para instalar dependencias da rockeseat
* deixe o .eslintrc.json com o "extends":"@rockeseat/eslint-config/node"
* garanta que no settings.json a opção codeActionOnSave esteja para eslint.fixAll : true (algo assim)
* no packtage.json:     "lint": "eslint src -e .ts --fix" em scripts
  * ele vai listar os erros e depois corrigir tudo de uma vez (--fix)
  * aparentemente a correção por salvamento só funciona depois de executar
    esse comando com --fix pelo menos uma vez

SQLite

* Muito parecido com mysql, postgresql, etc 
* Salvo em arquivos fisicos no repositorio da API
* não precisa subir nem baixar nada
* Formas de comunicação:
  * Biblioteca de baixo nivel (Drivers) que permitem conversar com o BD 
    * ex: nodesql2
    * você passa querys mais "cruas" , tipo as que vc usou no app java
  * QueryBuilders: não precisa saber tanto sobre query pq ele constroi pra ti 
    * Knex.js (mistura js e codigo sql para montar query num arquivo .sql automaticamente)
      * querybuildes a sintaxe é reaproveitada para todos os bancos que ela tem suporte
      * ou seja, você só muda a url com o tipo novo de banco que vc quer migrar e o codigo que
        vc fez ára buildar querys no banco anterior é convertido para a sintaxe do novo banco

KNEX.JS

* Primeiro instale o driver do banco que vc quer usar 
  * ex: npm install knex sqlite3 (instaladas na produção pq serão usadas em prod também)
  
MIGRATIONS - SQLite

* São histórico de todas as mudanças feitas no banco de dados
* Anotadas com data e horário das mudanças (linha do tempo)
* Há tabela criada chamada Migrations onde tenho esse histórico
* É tipo um git para banco de dados
* Comando para criação: npx knex migrate:make create-documents 
  * create-documents é o nome do arquivo
* Para configurar uma migration, foi preciso:
  1. Exportar configurações de conexão com banco (export cons config em database.ts) e importar num arquivo chamado knexfile.ts 
     que você cria na raiz do setup;
  2. Criação de um script no packtage.json: "knex": "node --import tsx ./node_modules/knex/bin/cli.js"
    2.1 Ele basicamente usa a engine do node para carregar o tsx (o transformador e compilador automatico ts->js)
        para executar o knex usando o arquivo knexfile.ts que tem as config do banco
  3. Com isso, uma pasta chamada migrations é criada com um arquivo ts (create-documents)